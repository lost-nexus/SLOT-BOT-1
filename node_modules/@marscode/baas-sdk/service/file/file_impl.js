"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.File = void 0;
const envs_1 = require("../../common/utils/envs");
const ctx_1 = require("../../common/utils/ctx");
const buffer_1 = require("buffer");
const request_1 = require("../request/request");
const stream_1 = require("stream");
const errors_1 = require("../../common/errors/errors");
const codes_1 = require("../../common/errors/codes");
const utils_1 = require("../../common/utils/utils");
const crypto = require('crypto');
class File {
    constructor(credential) {
        this.credential = credential;
    }
    async invoke(f) {
        if (!this.credential) {
            this.credential = (0, envs_1.getCredential)("file");
        }
        return await (0, ctx_1.getCtx)().run(async () => {
            const ctx = (0, ctx_1.getCtx)();
            ctx.credential = this.credential;
            return await ctx.run(f);
        });
    }
    async upload(fileName, content, options) {
        return await this.invoke(async () => {
            let s, size, md5Hash;
            if (typeof content === "string") {
                s = buffer_1.Buffer.from(content);
            }
            else if (content instanceof stream_1.Stream) {
                s = buffer_1.Buffer.from(await (0, utils_1.streamToString)(content));
            }
            else {
                throw new errors_1.BizError(codes_1.errCodeInvalid, { content: `the content should be string or Stream, but ${typeof content}` });
            }
            let preSignTimeout = undefined;
            if (options && options.preSignTimeout) {
                preSignTimeout = options.preSignTimeout;
            }
            // 1.预加签
            const resp = await (0, request_1.GetFileRequestInstance)().preSign({
                name: fileName,
                checkSumMD5: crypto.createHash('md5').update(s).digest('base64'),
                size: s.length,
                timeout: preSignTimeout,
            });
            let uploadTimeout = undefined;
            if (options && options.uploadTimeout) {
                uploadTimeout = options.uploadTimeout;
            }
            // 2.上传文件
            await (0, request_1.GetFileRequestInstance)().upload({
                content: s,
                fileName: fileName,
                url: resp.URL,
                additionalHeader: resp.AdditionalHeader,
                timeout: uploadTimeout,
            });
            // 3.转换返回
            return {
                id: resp.File.ID,
                name: resp.File.Name,
                size: resp.File.Size,
                url: resp.File.URL,
                createdAt: resp.File.CreatedAt,
                updatedAt: resp.File.UpdatedAt,
            };
        });
    }
    async download(fileID, options) {
        return await this.invoke(async () => {
            let queryTimeout = undefined, downloadTimeout = undefined;
            if (options && options.queryTimeout) {
                queryTimeout = options.queryTimeout;
            }
            if (options && options.downloadTimeout) {
                downloadTimeout = options.downloadTimeout;
            }
            const file = await (0, request_1.GetFileRequestInstance)().getFileByID({ fileID: fileID, timeout: queryTimeout });
            if (!file || !file.URL) {
                throw new errors_1.BizError(codes_1.errCodeInvalid, { content: `file (${fileID}) does not exist` });
            }
            const downloadResp = await (0, request_1.GetFileRequestInstance)().download({ url: file.URL, timeout: downloadTimeout });
            if (downloadResp) {
                return downloadResp.content;
            }
            return null;
        });
    }
    async delete(fileIds, options) {
        return await this.invoke(async () => {
            let timeout = undefined;
            if (options && options.timeout) {
                timeout = options.timeout;
            }
            await (0, request_1.GetFileRequestInstance)().delete({
                fileIDs: fileIds,
                timeout: timeout,
            });
        });
    }
    async list(param, options) {
        return await this.invoke(async () => {
            let timeout = undefined;
            if (options && options.timeout) {
                timeout = options.timeout;
            }
            // 1.请求
            const resp = await (0, request_1.GetFileRequestInstance)().list({
                pageSize: param.pageSize,
                pageNumber: param.pageNumber,
                prefix: param.prefix,
                timeout: timeout,
            });
            // 2.转换结果
            const result = { paginate: {}, data: [] };
            if (resp.Paginate) {
                result.paginate = {
                    pageSize: resp.Paginate.PageSize,
                    pageNumber: resp.Paginate.PageNumber,
                    totalCount: resp.Paginate.TotalCount,
                };
            }
            if (resp.Data) {
                for (let d of resp.Data) {
                    result.data.push({
                        id: d.ID,
                        name: d.Name,
                        size: d.Size,
                        url: d.URL,
                        createdAt: d.CreatedAt,
                        updatedAt: d.UpdatedAt,
                    });
                }
            }
            return result;
        });
    }
}
exports.File = File;
//# sourceMappingURL=file_impl.js.map