import { IRedis, TimeoutKeys } from "./redis";
import { Credential } from "../../common/structs/structs";
export declare class Redis implements IRedis {
    credential: Credential;
    options?: {
        [K in TimeoutKeys]?: number;
    };
    constructor(credential?: Credential);
    invoke(f: Function): Promise<any>;
    append(key: string, value: string): Promise<any>;
    zdecr(key: string): Promise<any>;
    bitcount(key: string, start: number, end: number): Promise<any>;
    decr(key: string): Promise<any>;
    decrby(key: string, decrement: number): Promise<any>;
    del(key: string, ...keys: string[]): Promise<any>;
    exists(key: string): Promise<any>;
    expire(key: string, seconds: number): Promise<any>;
    expireat(key: string, timestamp: number): Promise<any>;
    get(key: string): Promise<string>;
    getbit(key: string, offset: number): Promise<any>;
    getrange(key: string, start: number, end: number): Promise<any>;
    getset(key: string, value: string): Promise<any>;
    hdel(key: string, field: string, ...fields: string[]): Promise<any>;
    hexists(key: string, field: string): Promise<any>;
    hget(key: string, field: string): Promise<any>;
    hgetall(key: string): Promise<any>;
    hincrby(key: string, field: string, increment: number): Promise<any>;
    hincrbyfloat(key: string, field: string, increment: number): Promise<any>;
    hkeys(key: string): Promise<any>;
    hlen(key: string): Promise<any>;
    hmget(key: string, field: string, ...fields: string[]): Promise<any>;
    hmget(key: string, fields: string[]): Promise<any>;
    hmset(key: string, field: string, value: string, ...fieldValues: string[]): Promise<any>;
    hmset(key: string, kvMap: object): Promise<any>;
    hmset(key: string, kvArr: string[]): Promise<any>;
    hset(key: string, field: string, value: string): Promise<any>;
    hsetnx(key: string, field: string, value: string): Promise<any>;
    hvals(key: string): Promise<any>;
    incr(key: string): Promise<any>;
    incrby(key: string, increment: number): Promise<any>;
    incrbyfloat(key: string, increment: number): Promise<any>;
    lindex(key: string, index: number): Promise<any>;
    llen(key: string): Promise<any>;
    lpop(key: string): Promise<any>;
    lpush(key: string, value: string, ...values: string[]): Promise<any>;
    lpushx(key: string, value: string): Promise<any>;
    lrange(key: string, start: number, stop: number): Promise<any>;
    lrem(key: string, count: number, value: string): Promise<any>;
    lset(key: string, index: number, value: string): Promise<any>;
    ltrim(key: string, start: number, stop: number): Promise<any>;
    mget(key: string, ...keys: string[]): Promise<any>;
    mget(keys: string[]): Promise<any>;
    mset(key: string, value: string, ...keyAndValue: string[]): Promise<any>;
    mset(kvMap: object): Promise<any>;
    mset(kvArr: string[]): Promise<any>;
    persist(key: string): Promise<any>;
    pexpire(key: string, milliseconds: number): Promise<any>;
    pexpireat(key: string, millisecondsTimestamp: number): Promise<any>;
    pfadd(key: string, ...elements: string[]): Promise<any>;
    pfcount(key: string, ...keys: string[]): Promise<any>;
    pfmerge(dest: string, ...keys: string[]): Promise<any>;
    psetex(key: string, milliseconds: number, value: string): Promise<any>;
    pttl(key: string): Promise<any>;
    rpop(key: string): Promise<any>;
    rpoplpush(source: string, destination: string): Promise<any>;
    rpush(key: string, value: string, ...values: string[]): Promise<any>;
    rpushx(key: string, value: string): Promise<any>;
    sadd(key: string, member: string, ...members: string[]): Promise<any>;
    scard(key: string): Promise<any>;
    sdiff(key: string, ...keys: string[]): Promise<any>;
    sdiffstore(destination: string, key: string, ...keys: string[]): Promise<any>;
    set(key: string, value: string): Promise<any>;
    set(key: string, value: string, setType: "nx" | "xx"): Promise<any>;
    set(key: string, value: string, expireMode: "ex" | "px", expire: number): Promise<any>;
    set(key: string, value: string, expireMode: "ex" | "px", expire: number, setType: "nx" | "xx"): Promise<any>;
    setbit(key: string, offset: number, value: 0 | 1): Promise<any>;
    setex(key: string, seconds: number, value: string): Promise<any>;
    setnx(key: string, value: string): Promise<any>;
    setrange(key: string, offset: number, value: string): Promise<any>;
    sinter(key: string, ...keys: string[]): Promise<any>;
    sinterstore(destination: string, key: string, ...keys: string[]): Promise<any>;
    sismember(key: string, member: string): Promise<any>;
    smembers(key: string): Promise<any>;
    smove(source: string, destination: string, member: string): Promise<any>;
    spop(key: string, count?: number): Promise<any>;
    srandmember(key: string, count?: number): Promise<any>;
    srem(key: string, member: string, ...members: string[]): Promise<any>;
    strlen(key: string): Promise<any>;
    sunion(key: string, ...keys: string[]): Promise<any>;
    sunionstore(destination: string, key: string, ...keys: string[]): Promise<any>;
    ttl(key: string): Promise<any>;
    type(key: string): Promise<any>;
    zadd(key: string, score: number, member: string, ...scoreAndMembers: (number | string)[]): Promise<any>;
    zcard(key: string): Promise<any>;
    zcount(key: string, min: number | string, max: number | string): Promise<any>;
    zincrby(key: string, increment: number, member: string): Promise<any>;
    zinterstore(destination: string, numkeys: number, ...key: any[]): Promise<any>;
    zrange(key: string, start: number, stop: number, withscores?: "withscores"): Promise<any>;
    zrangebyscore(key: string, min: number | string, max: number | string): Promise<any>;
    zrank(key: string, member: string): Promise<any>;
    zrem(key: string, member: string, ...members: string[]): Promise<any>;
    zremrangebyrank(key: string, start: number, stop: number): Promise<any>;
    zremrangebyscore(key: string, min: number | string, max: number | string): Promise<any>;
    zrevrange(key: string, start: number, stop: number, withscores?: "withscores"): Promise<any>;
    zrevrangebyscore(key: string, max: number | string, min: number | string): Promise<any>;
    zrevrank(key: string, member: string): Promise<any>;
    zscore(key: string, member: string): Promise<any>;
    zunionstore(destination: string, numKeys: number, ...key: any[]): Promise<any>;
    setTimeout(options: {
        [K in TimeoutKeys]?: number;
    }): IRedis;
}
