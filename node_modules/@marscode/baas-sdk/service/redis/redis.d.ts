export type TimeoutKeys = 'append' | 'bitcount' | 'decr' | 'decrby' | 'del' | 'exists' | 'expire' | 'expireat' | 'get' | 'getbit' | 'getrange' | 'getset' | 'hdel' | 'hexists' | 'hget' | 'hgetall' | 'hincrby' | 'hincrbyfloa' | 'hkeys' | 'hlen' | 'hmget' | 'hmset' | 'hset' | 'hsetnx' | 'hvals' | 'incr' | 'incrby' | 'incrbyfloat' | 'lindex' | 'llen' | 'lpop' | 'lpush' | 'lpushx' | 'lrange' | 'lset' | 'ltrim' | 'mget' | 'mset' | 'persist' | 'pexpire' | 'pexpireat' | 'psetex' | 'pttl' | 'rpop' | 'rpoplpush' | 'rpush' | 'rpushx' | 'sadd' | 'sdiff' | 'sdiffstore' | 'set' | 'setbit' | 'setex' | 'setnx' | 'setrange' | 'sinter' | 'sinterstore' | 'sismember' | 'smembers' | 'smove' | 'spop' | 'srandmember' | 'srem' | 'strlen' | 'sunion' | 'sunionstore' | 'ttl' | 'type' | 'zadd' | 'zcard' | 'zcount' | 'zincrby' | 'zinterstore' | 'zrange' | 'zrangebyscore' | 'zrank' | 'zrem' | 'zremrangebyrank' | 'zremrangebyscore' | 'zrevrange' | 'zrevrangebyscore' | 'zrevrank' | 'zscore' | 'zunionstore';
export interface IRedis {
    /**
     * Set timeout period
     * @param options Key name
     */
    setTimeout(options: {
        [K in TimeoutKeys]?: number;
    }): IRedis;
    /**
     * Delete one or more keys
     * @param key Key name
     * @param keys Multiple key names
     */
    del(key: string, ...keys: string[]): Promise<number>;
    /**
     * Check whether a key exists
     * @param key Key name
     */
    exists(key: string): Promise<number>;
    /**
     * Set an expiration time for a key, in seconds
     * @param key Key name
     * @param seconds Time (seconds)
     */
    expire(key: string, seconds: number): Promise<number>;
    /**
     * Set an absolute expiration time for a key with second precision
     * @param key Key name
     * @param timestamp Absolute expiration time (precision: seconds)
     */
    expireat(key: string, timestamp: number): Promise<number>;
    /**
     * Persist a key, i.e., remove the expiration time set on the key and make it never expire
     * @param key Key name
     */
    persist(key: string): Promise<number>;
    /**
     * Set an expiration time for a key in milliseconds
     * @param key Key name
     * @param milliseconds Time (milliseconds)
     */
    pexpire(key: string, milliseconds: number): Promise<number>;
    /**
     * Set an absolute expiration time for a key in milliseconds
     * @param key Key name
     * @param millisecondsTimestamp Absolute expiration time (milliseconds)
     */
    pexpireat(key: string, millisecondsTimestamp: number): Promise<number>;
    /**
     * Returns the remaining lifetime of the key in milliseconds
     * @param key Key name
     */
    pttl(key: string): Promise<number>;
    /**
     * Returns the remaining lifetime of the key in seconds
     * @param key Key value
     */
    ttl(key: string): Promise<number>;
    /**
     * Returns the type of the key
     * @param key Key value
     */
    type(key: string): Promise<string>;
    /**
     * Appends a piece of content to the value of a key. If the key does not exist, it creates an empty string and appends to it
     * @param key Key value
     * @param value Append value
     */
    append(key: string, value: string): Promise<number>;
    /**
     * Counts the number of bits the value of a key occupies. If the key does not exist, it returns 0
     * @param key Key value
     * @param start Counting range interval left endpoint, closed interval
     * @param end Counting range interval right endpoint, closed interval
     */
    bitcount(key: string, start: number, end: number): Promise<number>;
    /**
     * Decrements the numeric value stored in a key by one, limited to signed 64-bit integers. If the key does not exist, it creates the value as zero, and then subtracts one
     * @param key Key value
     */
    zdecr(key: string): Promise<number>;
    /**
     * Performs a subtraction on the numeric value stored in a key, limited to signed 64-bit integers. If the key does not exist, it creates the value as zero, and then subtracts the define decrement
     * @param key Key value
     * @param decrement Decrease
     */
    decrby(key: string, decrement: number): Promise<number>;
    /**
     * Retrieves the value stored in a key
     * @param key Key value
     */
    get(key: string): Promise<string>;
    /**
     * Based on the offset to obtain the bit value of a key, if it exceeds the length of the stored value, it returns 0
     * @param key Key value
     * @param offset Offset
     */
    getbit(key: string, offset: number): Promise<number>;
    /**
     * An early version of the Redis SUBSTR method to get a substring
     * @param key Key value
     * @param start Start position of the substring
     * @param end End position of the substring
     */
    getrange(key: string, start: number, end: number): Promise<string>;
    /**
     * Atomically set the value of a key and return the value originally stored in the key. If the key does not exist, it sets it and returns nil
     * @param key Key value
     * @param value Value
     */
    getset(key: string, value: string): Promise<string>;
    /**
     * Increment the numeric value stored in a key by one, only for signed 64-bit integers. If the key does not exist, the value is created as zero and then incremented by one
     * @param key Key value
     */
    incr(key: string): Promise<number>;
    /**
     * Decrement the numeric value stored in a key by one, only for signed 64-bit integers. If the key does not exist, the value is created as zero and then subtracted by one
     * @param key Key value
     */
    decr(key: string): Promise<number>;
    /**
     * Increment the numeric value stored in a key, only for signed 64-bit integers. If the key does not exist, the value is created as zero and then added by the defined increment
     * @param key Key value
     * @param increment Increment
     */
    incrby(key: string, increment: number): Promise<number>;
    /**
     * Perform a floating point increment operation on the numeric value stored in a key. If the key does not exist, the value is created as a floating point zero and then added by the defined increment
     * @param key Key value
     * @param increment Increment (can be negative, can be expressed in scientific notation)
     */
    incrbyfloat(key: string, increment: number): Promise<number>;
    /**
     * Retrieves the values stored in multiple keys
     * @param key Key value
     * @param keys Multiple key values in optional parameter form
     */
    mget(key: string, ...keys: string[]): Promise<string[]>;
    /**
     * Retrieves the values stored in multiple keys
     * @param keys Multiple key values in array form
     */
    mget(keys: string[]): Promise<string[]>;
    /**
     * Set the value of a key and at the same time set the expiration time in milliseconds
     * @param key Key value
     * @param milliseconds Expiration time (milliseconds)
     * @param value Value
     */
    psetex(key: string, milliseconds: number, value: string): Promise<string>;
    /**
     * Set the value of a key
     * @param key Key value
     * @param value Value
     */
    set(key: string, value: string): Promise<string>;
    /**
     * Set the value of a key
     * @param key Key value
     * @param value Value
     * @param setType Set value type
     */
    set(key: string, value: string, setType: 'nx' | 'xx'): Promise<string>;
    /**
     * Set the value of a key
     * @param key Key value
     * @param value Value
     * @param expireMode Timeout type
     * @param expire Timeout
     */
    set(key: string, value: string, expireMode: 'ex' | 'px', expire: number): Promise<string>;
    /**
     * Set the value of a key
     * @param key Key value
     * @param value Value
     * @param expireMode Timeout type
     * @param expire Timeout
     * @param setType Set value type
     */
    set(key: string, value: string, expireMode: 'ex' | 'px', expire: number, setType: 'nx' | 'xx'): Promise<string>;
    /**
     * Set the value of multiple keys in batch
     * @param key
     * @param value
     * @param keyAndValue Key, value
     */
    mset(key: string, value: string, ...keyAndValue: string[]): Promise<string>;
    /**
     * Set the value of multiple keys in batch
     * @param kvMap Form of map
     */
    mset(kvMap: object): Promise<string>;
    /**
     * Set the value of multiple keys in batch
     * @param kvArr Array of strings
     */
    mset(kvArr: string[]): Promise<string>;
    /**
     * Set the bit value of a key stored at offset based on the offset
     * @param key Key value
     * @param offset Offset
     * @param value Value (0 or 1)
     */
    setbit(key: string, offset: number, value: 0 | 1): Promise<number>;
    /**
     * Set the key value and also set the expiration time in seconds
     * @param key Key value
     * @param seconds Expiration time (seconds)
     * @param value Value
     */
    setex(key: string, seconds: number, value: string): Promise<string>;
    /**
     * Set the value of a non-existent key, if the key already exists, the setting is invalid
     * @param key Key value
     * @param value Value
     */
    setnx(key: string, value: string): Promise<string>;
    /**
     * Set the value of a key stored at offset based on the offset
     * @param key Key value
     * @param offset Offset
     * @param value Value
     */
    setrange(key: string, offset: number, value: string): Promise<number>;
    /**
     * Get the length of value stored in a key, if the key does not exist, return 0
     * @param key Key value
     */
    strlen(key: string): Promise<number>;
    /**
     * Remove one or more fields from the hash structure stored in a key
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     * @param fields Multiple field names in the hash structure
     */
    hdel(key: string, field: string, ...fields: string[]): Promise<number>;
    /**
     * Check whether a field exists in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     */
    hexists(key: string, field: string): Promise<number>;
    /**
     * Get a field value from the hash structure stored in a key
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     */
    hget(key: string, field: string): Promise<string>;
    /**
     * Get all field names and values from the hash structure stored in a key
     * @param key Key of the hash structure
     */
    hgetall(key: string): Promise<Record<string, string>>;
    /**
     * Perform addition operation on a numeric field in the hash structure stored in a key, with integer increment
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     * @param increment Increment (integer)
     */
    hincrby(key: string, field: string, increment: number): Promise<number>;
    /**
     * Perform addition operation on a numeric field in the hash structure stored in a key, with floating point increment
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     * @param increment Increment (floating point)
     */
    hincrbyfloat(key: string, field: string, increment: number): Promise<number>;
    /**
     * Get all field names in the hash structure stored in a key
     * @param key Key of the hash structure
     */
    hkeys(key: string): Promise<string[]>;
    /**
     * Get the number of fields in the hash structure stored in a key
     * @param key Key of the hash structure
     */
    hlen(key: string): Promise<number>;
    /**
     * Get multiple field values in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param field Single field name in the hash structure
     * @param fields Multiple field names in optional parameter form
     */
    hmget(key: string, field: string, ...fields: string[]): Promise<string[]>;
    /**
     * Get multiple field values in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param fields Multiple field names in array form
     */
    hmget(key: string, fields: string[]): Promise<string[]>;
    /**
     * Batch set multiple field values in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param field Single field name in the hash structure
     * @param value Single value to be set
     * @param fieldValues Sequence of multiple field names and expected set values in the hash structure
     */
    hmset(key: string, field: string, value: string, ...fieldValues: string[]): Promise<number>;
    /**
     * Batch set multiple field values in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param kvMap Key value's map
     */
    hmset(key: string, kvMap: object): Promise<number>;
    /**
     * Batch set multiple field values in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param kvArr Array of key-values
     */
    hmset(key: string, kvArr: string[]): Promise<number>;
    /**
     * Set the field value in the hash structure stored in a key
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     * @param value Expected set value
     */
    hset(key: string, field: string, value: string): Promise<number>;
    /**
     * Set the value of a field that does not exist in the hash structure stored in a key. If the field already exists, the setting is invalid
     * @param key Key of the hash structure
     * @param field Field name in the hash structure
     * @param value Expected set value
     */
    hsetnx(key: string, field: string, value: string): Promise<number>;
    /**
     * Get all field values in the hash structure stored in a key
     * @param key Key of the hash structure
     */
    hvals(key: string): Promise<string[]>;
    /**
     * Get the value stored at an index in the list stored in a key
     * @param key Key of the list
     * @param index Index (starting from 0, can be negative)
     */
    lindex(key: string, index: number): Promise<string>;
    /**
     * Get the length of the list stored in a key
     * @param key Key of the list
     */
    llen(key: string): Promise<number>;
    /**
     * Remove and get the first value of the list stored in a key
     * @param key Key of the list
     */
    lpop(key: string): Promise<string>;
    /**
     * Sequentially insert one or more values at the first position of the list stored in a key, if the key does not exist, a list will be created
     * @param key Key of the list
     * @param value Single expected inserted value
     * @param values Multiple expected inserted values
     */
    lpush(key: string, value: string, ...values: string[]): Promise<number>;
    /**
     * Insert a value at the first position of the list stored in a key, no action will be taken if the key does not exist
     * @param key Key of the list
     * @param value Expected inserted value
     */
    lpushx(key: string, value: string): Promise<number>;
    /**
     * Get all values within a certain range in the list stored in a key
     * @param key Key of the list
     * @param start Range interval left endpoint, closed interval
     * @param stop Range interval right endpoint, closed interval
     */
    lrange(key: string, start: number, stop: number): Promise<string[]>;
    /**
     * Remove one or more values equal to a given value from the list stored in a key
     * @param key Key of the list
     * @param count Number of values to be removed; when greater than zero, it means to delete several values from head to tail of the list, when less than zero, it means to delete several values from tail to head, when equal to zero, it means to delete all values that meet the conditions
     * @param value Value to be removed
     */
    lrem(key: string, count: number, value: string): Promise<number>;
    /**
     * Set a value at a certain index in the list stored in a key
     * @param key Key of the list
     * @param index Index (starting from 0, can be negative)
     * @param value Expected set value
     */
    lset(key: string, index: number, value: string): Promise<number>;
    /**
     * Remove all values within a certain range in the list stored in a key, if the left endpoint of the range is larger than the right endpoint, the entire list will be removed
     * @param key Key of the list
     * @param start Range interval left endpoint, closed interval
     * @param stop Range interval right endpoint, closed interval
     */
    ltrim(key: string, start: number, stop: number): Promise<string>;
    /**
     * Remove and get the last value of the list stored in a key
     * @param key Key of the list
     */
    rpop(key: string): Promise<string>;
    /**
     * Atomically remove the last value in the list stored in source and insert it at the first location in the list stored in destination
     * @param source Key of the source list
     * @param destination Key of the destination list
     */
    rpoplpush(source: string, destination: string): Promise<string>;
    /**
     * Sequentially insert one or more values at the end of the list stored in key, if key does not exist, a list will be created
     * @param key Key of the list
     * @param value Single expected inserted value
     * @param values Multiple expected inserted values
     */
    rpush(key: string, value: string, ...values: string[]): Promise<number>;
    /**
     * Insert a given value at the end of the list stored in key, no operation is performed if key does not exist
     * @param key Key of the list
     * @param value Expected inserted value
     */
    rpushx(key: string, value: string): Promise<number>;
    /**
     * Add an element to the set stored in a key
     * @param key Key of the set
     * @param member Single expected added element
     * @param members Multiple expected added elements
     */
    sadd(key: string, member: string, ...members: string[]): Promise<number>;
    /**
     * Get the number of elements in the set stored in a key
     * @param key Key of the set
     */
    scard(key: string): Promise<number>;
    /**
     * Get the difference between the first set and all subsequent sets
     * @param key Key of the set
     * @param keys Keys of subsequent sets
     */
    sdiff(key: string, ...keys: string[]): Promise<string[]>;
    /**
     * Store the difference between the first set and all subsequent sets in destination
     * @param destination Key of the destination set
     * @param key Key of the set
     * @param keys Keys of subsequent sets
     */
    sdiffstore(destination: string, key: string, ...keys: string[]): Promise<number>;
    /**
     * Get the intersection of one or more sets
     * @param key Single set key
     * @param keys Multiple set keys
     */
    sinter(key: string, ...keys: string[]): Promise<string[]>;
    /**
     * Store the intersection of one or more sets in destination
     * @param destination Target set key
     * @param key Single set key
     * @param keys Multiple set keys
     */
    sinterstore(destination: string, key: string, ...keys: string[]): Promise<number>;
    /**
     * Check if an element value exists in the set stored in key
     * @param key Set key
     * @param member Element value
     */
    sismember(key: string, member: string): Promise<number>;
    /**
     * Get all element values in the set stored in key
     * @param key Set key
     */
    smembers(key: string): Promise<number>;
    /**
     * Move a certain element from the set stored in source to the set stored in destination
     * @param source Source set key
     * @param destination Target set key
     * @param member Element value
     */
    smove(source: string, destination: string, member: string): Promise<number>;
    /**
     * Randomly remove and get one or more element values from the set stored in key
     * @param key Set key
     * @param count Optional parameter; number of elements
     */
    spop(key: string, count?: number): Promise<string[]>;
    /**
     * Randomly get one or more element values from the set stored in key
     * @param key Set key
     * @param count Optional parameter; number of elements
     */
    srandmember(key: string, count?: number): Promise<string[]>;
    /**
     * Remove one or more elements from the set stored in key
     * @param key Set key
     * @param member A single element value to be deleted
     * @param members Multiple element values to be deleted
     */
    srem(key: string, member: string, ...members: string[]): Promise<number>;
    /**
     * Get the union of one or more sets
     * @param key Single set key
     * @param keys Multiple set keys
     */
    sunion(key: string, ...keys: string[]): Promise<string[]>;
    /**
     * Store the union of one or more sets in destination
     * @param destination Target set key
     * @param key Single set key
     * @param keys Multiple set keys
     */
    sunionstore(destination: string, key: string, ...keys: string[]): Promise<number>;
    /**
     * Add elements and corresponding scores to the sorted set stored in key
     * @param key Key of the sorted set
     * @param score Expected score of the element to be added, used for sorting
     * @param member Expected element value to be added
     * @param scoreAndMembers Multiple score, member pairs
     */
    zadd(key: string, score: number, member: string, ...scoreAndMembers: (number | string)[]): Promise<number>;
    /**
     * Get the number of elements in the sorted set stored in a key
     * @param key Key of the sorted set
     */
    zcard(key: string): Promise<number>;
    /**
     * Get the number of elements in the sorted set stored in a key with scores between min and max
     * @param key Key of the sorted set
     * @param min Minimum score, closed interval, supports '(' for open interval specification
     * @param max Maximum score, closed interval, supports '(' for open interval specification
     */
    zcount(key: string, min: number | string, max: number | string): Promise<number>;
    /**
     * Perform the add operation on the score of an element in the sorted set stored in key
     * @param key Key of the sorted set
     * @param increment Increment of the score
     * @param member Element value
     */
    zincrby(key: string, increment: number, member: string): Promise<number>;
    /**
     * Get elements in the sorted set stored in key, which are ranked between start and stop
     * The index starts from 0
     * @param key Key of the sorted set
     * @param start The left endpoint of the range, is a closed interval
     * @param stop The right endpoint of the range, is a closed interval.
     * @param withscores Result comes with scores
     */
    zrange(key: string, start: number, stop: number, withscores?: 'withscores'): Promise<string[]>;
    /**
     * Get elements in the sorted set stored in key, which have scores between min and max
     * @param key Key of the sorted set
     * @param min The left endpoint of the range, closed interval
     * @param max The right endpoint of the range, closed interval
     */
    zrangebyscore(key: string, min: (number | string), max: (number | string)): Promise<string[]>;
    /**
     * Get the ranking (in ascending order) of a certain element in the sorted set stored in key
     * The index starts from 0
     * @param key Key of the sorted set
     * @param member Element value
     */
    zrank(key: string, member: string): Promise<number>;
    /**
     * Remove one or more element values in the sorted set stored in key
     * @param key Key of the sorted set
     * @param member Single element value
     * @param members Multiple element values
     */
    zrem(key: string, member: string, ...members: string[]): Promise<number>;
    /**
     * Remove several elements in the sorted set stored in key by a given ranking range
     * The index starts from 0
     * @param key Key of the sorted set
     * @param start The left endpoint of the range, is a closed interval
     * @param stop The right endpoint of the range, is a closed interval
     */
    zremrangebyrank(key: string, start: number, stop: number): Promise<number>;
    /**
     * Remove several elements in the sorted set stored in key by a given score range
     * @param key Key of the sorted set
     * @param min The left endpoint of the range, is a closed interval
     * @param max The right endpoint of the range, is a closed interval
     */
    zremrangebyscore(key: string, min: (number | string), max: (number | string)): Promise<number>;
    /**
     * Get several elements within a given ranking range in the sorted set stored in key in reverse order
     * The index starts from 0
     * @param key Key of the sorted set
     * @param start The left endpoint of the range, is a closed interval
     * @param stop The right endpoint of the range, is a closed interval
     * @param withscores Result comes with scores
     */
    zrevrange(key: string, start: number, stop: number, withscores?: 'withscores'): Promise<string>;
    /**
     * Get several elements within a given score range in the sorted set stored in key in reverse order
     * @param key Key of the sorted set
     * @param max The right endpoint of the range, is a closed interval
     * @param min The left endpoint of the range, is a closed interval
     */
    zrevrangebyscore(key: string, max: (number | string), min: (number | string)): Promise<string[]>;
    /**
     * Get the ranking (in descending order) of a certain element in the sorted set stored in key
     * The index starts from 0
     * @param key Key of the sorted set
     * @param member Element value
     */
    zrevrank(key: string, member: string): Promise<number>;
    /**
     * Get the score of a certain element in the sorted set stored in key
     * @param key Key of the sorted set
     * @param member Element value
     */
    zscore(key: string, member: string): Promise<number>;
    /**
     * Store the intersection of one or more sorted sets in destination, where the scores of elements in the intersection are the sum of the scores
     * @param destination Key of the target sorted set
     * @param numkeys Number of sorted sets
     * @param key Keys of multiple sorted sets
     */
    zinterstore(destination: string, numkeys: number, ...key: any[]): Promise<number>;
    /**
     * Store the union of one or more sorted sets in destination, where the scores of the elements in the set are the sum of the scores
     * @param destination Key of the target sorted set
     * @param numKeys The number of sorted sets
     * @param key Keys of multiple sorted sets
     */
    zunionstore(destination: string, numKeys: number, ...key: any[]): Promise<number>;
}
