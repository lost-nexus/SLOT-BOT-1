"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceCredential = exports.getToken = void 0;
const option_1 = require("./option");
const path_1 = require("./path");
const request_1 = require("./request");
const ctx_1 = require("../../common/utils/ctx");
const errors_1 = require("../../common/errors/errors");
const codes_1 = require("../../common/errors/codes");
const resIDToToken = {};
async function getToken() {
    const credential = (0, ctx_1.getCredentialFromCtx)();
    if (!credential) {
        throw new errors_1.BizError(codes_1.errCodeInvalid, { content: `resourceID and secret is empty` });
    }
    const key = `${credential.resourceID}:${credential.secret}`;
    let tokenInfo = resIDToToken[key];
    if (tokenInfo) {
        return await tokenInfo.getToken();
    }
    resIDToToken[key] = new ResourceCredential(credential);
    return await resIDToToken[key].getToken();
}
exports.getToken = getToken;
class ResourceCredential {
    constructor(credential) {
        this.resourceID = credential.resourceID;
        this.secret = credential.secret;
        this.refreshSecond = 600; // 当前定为 10分钟
    }
    async getToken() {
        if (this.expireSecond - new Date().getTime() / 1000 > this.refreshSecond) {
            return this.token;
        }
        return await this.refreshToken();
    }
    async refreshToken() {
        const options = (0, option_1.getOptions)(path_1.baasApiKeys.getToken);
        let urlPath = options._reqPath;
        options.json = {
            ResourceID: this.resourceID,
            Secret: this.secret,
        };
        const resp = await (0, request_1.doJsonReq)(urlPath, options, { skipToken: true });
        this.token = resp.Token;
        this.expireSecond = resp.ExpireSecond;
        return resp.Token;
    }
}
exports.ResourceCredential = ResourceCredential;
//# sourceMappingURL=getToken.js.map